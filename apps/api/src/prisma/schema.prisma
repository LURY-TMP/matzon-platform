generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
  ORGANIZER
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BANNED
  SUSPENDED
}

enum TournamentStatus {
  DRAFT
  REGISTRATION
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TournamentFormat {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum NotificationType {
  TOURNAMENT_JOINED
  TOURNAMENT_STARTED
  TOURNAMENT_COMPLETED
  MATCH_SCHEDULED
  MATCH_STARTED
  MATCH_COMPLETED
  RANK_CHANGED
  FOLLOW_NEW
  ACHIEVEMENT_UNLOCKED
  SYSTEM_ANNOUNCEMENT
}

enum FeedEventType {
  USER_FOLLOWED
  TOURNAMENT_CREATED
  TOURNAMENT_JOINED
  TOURNAMENT_WON
  MATCH_COMPLETED
  MATCH_WON
  LEVEL_UP
  RANK_CHANGED
  ACHIEVEMENT
}

enum ReputationEventType {
  FOLLOW_RECEIVED
  FOLLOW_GIVEN
  MATCH_WIN
  MATCH_LOSS
  MATCH_PLAYED
  TOURNAMENT_JOIN
  TOURNAMENT_TOP3
  TOURNAMENT_WIN
  REPORT_RECEIVED
  REPORT_VALIDATED
  SPAM_DETECTED
  ACCOUNT_AGE_BONUS
  STREAK_BONUS
}

enum TrustLevel {
  NEW
  BASIC
  TRUSTED
  VETERAN
  ELITE
}

enum ReportTargetType {
  USER
  MATCH
  TOURNAMENT
  COMMENT
}

enum ReportReason {
  SPAM
  ABUSE
  CHEATING
  IMPERSONATION
  HARASSMENT
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  CONFIRMED
  REJECTED
}

enum AuditAction {
  REPORT_CREATED
  REPORT_RESOLVED
  PENALTY_APPLIED
  TRUST_OVERRIDE
  REPUTATION_RECALC
  USER_BANNED
  USER_SUSPENDED
  USER_REINSTATED
  ADMIN_OVERRIDE
}

model User {
  id                String     @id @default(uuid())
  username          String     @unique
  email             String     @unique
  passwordHash      String
  role              UserRole   @default(USER)
  status            UserStatus @default(ACTIVE)
  avatarUrl         String?
  bio               String?
  level             Int        @default(1)
  xp                Int        @default(0)
  reputationScore   Float      @default(0)
  trustLevel        TrustLevel @default(NEW)
  reportsReceived   Int        @default(0)
  restrictedUntil   DateTime?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  profile             Profile?
  refreshTokens       RefreshToken[]
  organizedTournaments Tournament[]
  participations      TournamentParticipant[]
  matchesAsPlayerOne  Match[] @relation("PlayerOne")
  matchesAsPlayerTwo  Match[] @relation("PlayerTwo")
  matchesWon          Match[] @relation("Winner")

  followers           Follow[] @relation("Following")
  following           Follow[] @relation("Followers")
  notifications       Notification[]
  feedEvents          FeedEvent[] @relation("FeedActor")
  reputationEvents    ReputationEvent[] @relation("ReputationUser")
  reportsFiled        Report[] @relation("Reporter")
  reportsAgainst      Report[] @relation("ReportTarget")
  auditLogs           AuditLog[] @relation("AuditActor")

  @@map("users")
}

model Profile {
  id            String   @id @default(uuid())
  userId        String   @unique
  followers     Int      @default(0)
  following     Int      @default(0)
  matchesPlayed Int      @default(0)
  wins          Int      @default(0)
  losses        Int      @default(0)
  rank          Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model RefreshToken {
  id          String    @id @default(uuid())
  token       String    @unique
  userId      String
  deviceId    String?
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  revokedAt   DateTime?

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following   User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId, createdAt(sort: Desc)])
  @@index([followingId, createdAt(sort: Desc)])
  @@map("follows")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  actorId   String?
  payload   Json?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("notifications")
}

model FeedEvent {
  id        String        @id @default(uuid())
  actorId   String
  type      FeedEventType
  title     String
  summary   String
  payload   Json?
  createdAt DateTime      @default(now())

  actor     User          @relation("FeedActor", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([actorId, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("feed_events")
}

model ReputationEvent {
  id        String              @id @default(uuid())
  userId    String
  actorId   String?
  type      ReputationEventType
  value     Float
  reason    String?
  metadata  Json?
  createdAt DateTime            @default(now())

  user      User                @relation("ReputationUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, type])
  @@map("reputation_events")
}

model Report {
  id            String           @id @default(uuid())
  reporterId    String
  targetUserId  String?
  targetType    ReportTargetType
  targetId      String?
  reason        ReportReason
  description   String?
  status        ReportStatus     @default(PENDING)
  resolvedBy    String?
  resolvedNote  String?
  createdAt     DateTime         @default(now())
  resolvedAt    DateTime?

  reporter      User             @relation("Reporter", fields: [reporterId], references: [id])
  targetUser    User?            @relation("ReportTarget", fields: [targetUserId], references: [id])

  @@index([targetUserId, status])
  @@index([status, createdAt(sort: Desc)])
  @@index([reporterId, createdAt(sort: Desc)])
  @@map("reports")
}

model AuditLog {
  id        String      @id @default(uuid())
  actorId   String
  action    AuditAction
  targetId  String?
  details   Json?
  createdAt DateTime    @default(now())

  actor     User        @relation("AuditActor", fields: [actorId], references: [id])

  @@index([actorId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
  @@index([targetId])
  @@map("audit_logs")
}

model Tournament {
  id              String              @id @default(uuid())
  name            String
  game            String
  description     String?
  format          TournamentFormat    @default(SINGLE_ELIMINATION)
  status          TournamentStatus    @default(DRAFT)
  maxPlayers      Int
  prizePool       String?
  rules           String?
  startDate       DateTime
  endDate         DateTime?
  organizerId     String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  organizer       User                @relation(fields: [organizerId], references: [id])
  participants    TournamentParticipant[]
  matches         Match[]

  @@index([game])
  @@index([status])
  @@index([organizerId])
  @@map("tournaments")
}

model TournamentParticipant {
  id            String     @id @default(uuid())
  tournamentId  String
  userId        String
  seed          Int?
  placement     Int?
  joinedAt      DateTime   @default(now())

  tournament    Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user          User       @relation(fields: [userId], references: [id])

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@map("tournament_participants")
}

model Match {
  id            String      @id @default(uuid())
  tournamentId  String?
  game          String
  round         Int?
  status        MatchStatus @default(SCHEDULED)
  playerOneId   String
  playerTwoId   String
  scoreOne      Int?
  scoreTwo      Int?
  winnerId      String?
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  tournament    Tournament? @relation(fields: [tournamentId], references: [id])
  playerOne     User        @relation("PlayerOne", fields: [playerOneId], references: [id])
  playerTwo     User        @relation("PlayerTwo", fields: [playerTwoId], references: [id])
  winner        User?       @relation("Winner", fields: [winnerId], references: [id])

  @@index([tournamentId])
  @@index([status])
  @@index([playerOneId])
  @@index([playerTwoId])
  @@map("matches")
}
